# minutes per appointment (mpa)
mpa_ib = tot_minutes_in_in_basket_per_appointment,
mpa_cr = tot_minutes_in_clinical_review_per_appointment,
mpa_nl = tot_minutes_in_notes_letters_per_appointment,
mpa_or = tot_minutes_in_orders_per_appointment,
mpa = mpa_ib + mpa_cr + mpa_nl + mpa_or,
mpa_pct_ib = ifelse(mpa_ib > 0, mpa_ib / mpa, NA),
mpa_pct_cr = ifelse(mpa_cr > 0, mpa_cr / mpa, NA),
mpa_pct_nl = ifelse(mpa_nl > 0, mpa_nl / mpa, NA),
mpa_pct_or = ifelse(mpa_or > 0, mpa_or / mpa, NA),
# --- Inbox metrics ---
# message (msg) metrics
msg_mar_tot = tot_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_tot = tot_count_of_patient_call_messages_received,
msg_res_tot = tot_count_of_result_messages_received,
msg_rxa_tot = tot_count_of_rx_auth_messages_received,
msg_all_tot = msg_mar_tot + msg_pcm_tot + msg_res_tot + msg_rxa_tot,
msg_mar_pmo = msg_mar_tot / n_months,
msg_pcm_pmo = msg_pcm_tot / n_months,
msg_res_pmo = msg_res_tot / n_months,
msg_rxa_pmo = msg_rxa_tot / n_months,
msg_all_pmo = msg_all_tot / n_months,
msg_mar_max = max_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_max = max_count_of_patient_call_messages_received,
msg_res_max = max_count_of_result_messages_received,
msg_rxa_max = max_count_of_rx_auth_messages_received,
msg_mar_dtc = tot_average_days_until_patient_medical_advice_request_message_marked_done,
msg_pcm_dtc = tot_average_days_until_patient_call_messages_marked_done,
msg_res_dtc = tot_average_days_until_result_message_marked_done,
msg_rxa_dtc = tot_average_days_until_rx_auth_message_marked_done,
msg_all_dtc = (msg_mar_dtc + msg_pcm_dtc + msg_res_dtc + msg_rxa_dtc) / 4,
msg_mar_itc_rat = if_else(
tot_count_of_patient_medical_advice_requests_messages_completed > 0,
tot_count_of_patient_medical_advice_requests_messages_incomplete /
tot_count_of_patient_medical_advice_requests_messages_completed,
NA_real_
),
msg_pcm_itc_rat = if_else(
tot_count_of_patient_call_messages_completed > 0,
tot_count_of_patient_call_messages_incomplete /
tot_count_of_patient_call_messages_completed,
NA_real_
),
msg_res_itc_rat = if_else(
tot_count_of_result_messages_completed > 0,
tot_count_of_result_messages_incomplete /
tot_count_of_result_messages_completed,
NA_real_
),
msg_all_itc_rat = if_else(
(tot_count_of_patient_medical_advice_requests_messages_completed +
tot_count_of_patient_call_messages_completed +
tot_count_of_result_messages_completed) > 0,
(tot_count_of_patient_medical_advice_requests_messages_incomplete +
tot_count_of_patient_call_messages_incomplete +
tot_count_of_result_messages_incomplete) /
(tot_count_of_patient_medical_advice_requests_messages_completed +
tot_count_of_patient_call_messages_completed +
tot_count_of_result_messages_completed),
NA_real_
),
# in-basket (ib) metrics
ib_mts = tot_count_of_in_basket_minutes,
ib_hrs = ib_mts / 60,
ib_hrs_pmo = ib_hrs / n_months,
ib_mts_per_apt = ib_mts / apt_tot,
ib_sys_rat = ib_mts / sys_mts_tot,
ib_sch_rat = ib_hrs / sch_hrs_tot
) |>
select(
id, type, group, n_months,
starts_with(c("msg_", "ib_", "sch_", "sys_", "aft_", "apt_", "mpa_"))
)
# Filter to providers with at least 3 months of data
final <- engineered |> filter(n_months >= 3)
# Save all datasets
if (!dir.exists("data")) {
dir.create("data")
}
raw |> saveRDS("data/raw.rds")
clean |> saveRDS("data/clean.rds")
wide |> saveRDS("data/wide.rds")
long |> saveRDS("data/long.rds")
monthly |> saveRDS("data/monthly.rds")
aggregated |> saveRDS("data/aggregated.rds")
engineered |> saveRDS("data/engineered.rds")
final |> saveRDS("data/final.rds")
View(engineered)
# Load libraries
library(readxl)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(janitor)
library(lubridate)
# Load raw data
messages <- read_excel("Epic Signal PEP Data.xlsx", sheet = "Messages")
time <- read_excel("Epic Signal PEP Data.xlsx", sheet = "Time")
raw <- bind_rows(messages, time)
# Initial exploration
str(raw)
head(raw)
sort(unique(raw$Metric))
# Data cleaning
clean <- raw |>
mutate(
id = as.character(DE_ID),
type = factor(
case_when(
Grouper == "PHYSICIAN + PSYCHIATRIST" ~ "MD",
Grouper == "NURSE PRACTITIONER" ~ "NP",
Grouper == "RESIDENT + FELLOW" ~ "RF",
TRUE ~ Grouper
),
levels = c("MD", "NP", "RF")
),
group =
factor(
case_when(
type %in% c("MD", "NP") ~ "Staff",
TRUE ~ "Trainee"
),
levels = c("Staff", "Trainee")
),
# fix typo
metric = str_replace(Metric, "Recieved", "Received")
) |>
# remove duplicates
distinct(id, type, metric, .keep_all = TRUE) |>
# select columns
select(id, type, group, metric, starts_with(c("24-", "25-")))
# Reshape
wide <- clean |>
pivot_longer(starts_with(c("24-", "25-")), names_to = "month", values_to = "value") |>
pivot_wider(names_from = c("metric", "month"), values_from = "value") |>
clean_names()
long <- clean |>
pivot_longer(starts_with(c("24-", "25-")), names_to = "month", values_to = "value") |>
mutate(
month = ym(month)
)
monthly <- long |>
pivot_wider(names_from = metric, values_from = value) |>
clean_names()
# Aggregate
aggregated <- clean |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
# Engineer
engineered <- aggregated |>
transmute(
# object identifiers
id, type, group, n_months,
# --- General Metrics ---
# schedule (sch) metrics
sch_day_tot = tot_count_of_scheduled_days,
sch_day_pmo = sch_day_tot / n_months,
sch_hrs_tot = tot_scheduled_hours_per_day * sch_day_tot,
sch_hrs_pmo = sch_hrs_tot / n_months,
# system (sys) metrics
sys_mts_tot = tot_count_of_minutes_in_the_system,
sys_hrs_tot = sys_mts_tot / 60,
sys_hrs_pmo = sys_hrs_tot / n_months,
# afterhours (aft) metrics
aft_mts_ost = tot_count_of_minutes_active_outside_scheduled_time_30_min_buffer,
aft_mts_oud = tot_count_of_minutes_active_on_unscheduled_days,
aft_mts_sat = tot_count_of_saturday_minutes,
aft_mts_sun = tot_count_of_sunday_minutes,
aft_mts = aft_mts_ost + aft_mts_oud + aft_mts_sat + aft_mts_sun,
aft_hrs = aft_mts / 60,
aft_hrs_sys_rat = aft_mts / sys_mts_tot,
# appointment (apt) metrics
apt_tot = tot_count_of_appointments,
apt_pmo = apt_tot / n_months, # pmo = per month
apt_min = min_count_of_appointments,
apt_max = max_count_of_appointments,
# minutes per appointment (mpa)
mpa_ib = tot_minutes_in_in_basket_per_appointment,
mpa_cr = tot_minutes_in_clinical_review_per_appointment,
mpa_nl = tot_minutes_in_notes_letters_per_appointment,
mpa_or = tot_minutes_in_orders_per_appointment,
mpa = mpa_ib + mpa_cr + mpa_nl + mpa_or,
mpa_pct_ib = ifelse(mpa_ib > 0, mpa_ib / mpa, NA),
mpa_pct_cr = ifelse(mpa_cr > 0, mpa_cr / mpa, NA),
mpa_pct_nl = ifelse(mpa_nl > 0, mpa_nl / mpa, NA),
mpa_pct_or = ifelse(mpa_or > 0, mpa_or / mpa, NA),
# --- Inbox metrics ---
# message (msg) metrics
msg_mar_tot = tot_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_tot = tot_count_of_patient_call_messages_received,
msg_res_tot = tot_count_of_result_messages_received,
msg_rxa_tot = tot_count_of_rx_auth_messages_received,
msg_all_tot = msg_mar_tot + msg_pcm_tot + msg_res_tot + msg_rxa_tot,
msg_mar_pmo = msg_mar_tot / n_months,
msg_pcm_pmo = msg_pcm_tot / n_months,
msg_res_pmo = msg_res_tot / n_months,
msg_rxa_pmo = msg_rxa_tot / n_months,
msg_all_pmo = msg_all_tot / n_months,
msg_mar_max = max_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_max = max_count_of_patient_call_messages_received,
msg_res_max = max_count_of_result_messages_received,
msg_rxa_max = max_count_of_rx_auth_messages_received,
msg_mar_dtc = tot_average_days_until_patient_medical_advice_request_message_marked_done,
msg_pcm_dtc = tot_average_days_until_patient_call_messages_marked_done,
msg_res_dtc = tot_average_days_until_result_message_marked_done,
msg_rxa_dtc = tot_average_days_until_rx_auth_message_marked_done,
msg_all_dtc = (msg_mar_dtc + msg_pcm_dtc + msg_res_dtc + msg_rxa_dtc) / 4,
# in-basket (ib) metrics
ib_mts = tot_count_of_in_basket_minutes,
ib_mts_max = max_count_of_in_basket_minutes,
ib_hrs = ib_mts / 60,
ib_hrs_max = ib_mts_max / 60,
ib_hrs_pmo = ib_hrs / n_months,
ib_mts_per_apt = ib_mts / apt_tot,
ib_sys_rat = ib_mts / sys_mts_tot,
ib_sch_rat = ib_hrs / sch_hrs_tot
) |>
select(
id, type, group, n_months,
starts_with(c("msg_", "ib_", "sch_", "sys_", "aft_", "apt_", "mpa_"))
)
# Filter to providers with at least 3 months of data
final <- engineered |> filter(ib_hrs_max >= 1)
# Save all datasets
if (!dir.exists("data")) {
dir.create("data")
}
raw |> saveRDS("data/raw.rds")
clean |> saveRDS("data/clean.rds")
wide |> saveRDS("data/wide.rds")
long |> saveRDS("data/long.rds")
monthly |> saveRDS("data/monthly.rds")
aggregated |> saveRDS("data/aggregated.rds")
engineered |> saveRDS("data/engineered.rds")
final |> saveRDS("data/final.rds")
View(final)
# Filter to providers with at least 3 months of data
final <- engineered |> filter(sch_hrs_pmo >= 20)
View(final)
# Filter to providers with at least 20 scheduled hours per month
final <- engineered |> filter(sch_hrs_max >= 20)
# Filter to providers with at least 20 scheduled hours per month
final <- engineered |> filter(sch_hrs_pmo >= 12)
# Filter to providers with at least 0.1 FTE (schedule hours per month >= 16 hours)
final <- engineered |> filter(sch_hrs_pmo >= 16)
# Aggregate
aggregated <- clean |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
sch_hrs = mean(c_across(starts_with("Scheduled Hours Per Day") * starts_with("Count Of Scheduled Days"), na.rm = TRUE)),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
sch_hrs = (starts_with("Scheduled Hours Per Day") * starts_with("Count Of Scheduled Days"),
# Aggregate
aggregated <- clean |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
sch_hrs = starts_with("Scheduled Hours Per Day") * starts_with("Count Of Scheduled Days"),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
# Aggregate
aggregated <- clean |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
# starts_with("Scheduled Hours Per Day") * starts_with("Count Of Scheduled Days")
sch_hrs = ifelse(metric == "Scheduled Hours Per Day",
c_across(starts_with("Scheduled Hours Per Day")) *
clean |> filter(metric == "Count Of Scheduled Days") |>
rowwise() |>
mutate(
tot = sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> pull(tot),
NA),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
View(aggregated)
# Aggregate
aggregated <- clean |>
mutate(
# get sch_hrs from "Scheduled Hours Per Day" * "Count Of Scheduled Days" for each month
across(
starts_with(c("24-", "25-")),
~ ifelse(metric == "Scheduled Hours Per Day",
.x * clean[[which(clean$metric == "Count Of Scheduled Days")]][match(clean$id, id)],
.x)
)
) |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
View(aggregated)
# Load libraries
library(readxl)
library(readr)
library(dplyr)
library(tidyr)
library(stringr)
library(janitor)
library(lubridate)
# Load raw data
messages <- read_excel("Epic Signal PEP Data.xlsx", sheet = "Messages")
time <- read_excel("Epic Signal PEP Data.xlsx", sheet = "Time")
raw <- bind_rows(messages, time)
# Initial exploration
str(raw)
head(raw)
sort(unique(raw$Metric))
# Data cleaning
clean <- raw |>
mutate(
id = as.character(DE_ID),
type = factor(
case_when(
Grouper == "PHYSICIAN + PSYCHIATRIST" ~ "MD",
Grouper == "NURSE PRACTITIONER" ~ "NP",
Grouper == "RESIDENT + FELLOW" ~ "RF",
TRUE ~ Grouper
),
levels = c("MD", "NP", "RF")
),
group =
factor(
case_when(
type %in% c("MD", "NP") ~ "Staff",
TRUE ~ "Trainee"
),
levels = c("Staff", "Trainee")
),
# fix typo
metric = str_replace(Metric, "Recieved", "Received")
) |>
# remove duplicates
distinct(id, type, metric, .keep_all = TRUE) |>
# select columns
select(id, type, group, metric, starts_with(c("24-", "25-")))
# Reshape
wide <- clean |>
pivot_longer(starts_with(c("24-", "25-")), names_to = "month", values_to = "value") |>
pivot_wider(names_from = c("metric", "month"), values_from = "value") |>
clean_names()
long <- clean |>
pivot_longer(starts_with(c("24-", "25-")), names_to = "month", values_to = "value") |>
mutate(
month = ym(month)
)
monthly <- long |>
pivot_wider(names_from = metric, values_from = value) |>
clean_names()
# Aggregate
aggregated <- clean |>
rowwise() |>
mutate(
n_months = sum(!is.na(c_across(starts_with(c("24-", "25-"))))),
tot = ifelse(str_starts(metric, "Count Of"),
sum(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
mean(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)),
min = min(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE),
max = max(c_across(starts_with(c("24-", "25-"))), na.rm = TRUE)
) |> ungroup() |>
select(id, type, n_months, group, metric, tot, min, max) |>
pivot_wider(
names_from = metric,
values_from = c(tot, min, max),
names_sep = "_"
) |> clean_names()
# Engineer
engineered <- aggregated |>
transmute(
# object identifiers
id, type, group, n_months,
# --- General Metrics ---
# schedule (sch) metrics
sch_day_tot = tot_count_of_scheduled_days,
sch_day_pmo = sch_day_tot / n_months,
sch_day_max = max_count_of_scheduled_days,
sch_hrs_tot = tot_scheduled_hours_per_day * sch_day_tot,
sch_hrs_pmo = sch_hrs_tot / n_months,
# system (sys) metrics
sys_mts_tot = tot_count_of_minutes_in_the_system,
sys_hrs_tot = sys_mts_tot / 60,
sys_hrs_pmo = sys_hrs_tot / n_months,
# afterhours (aft) metrics
aft_mts_ost = tot_count_of_minutes_active_outside_scheduled_time_30_min_buffer,
aft_mts_oud = tot_count_of_minutes_active_on_unscheduled_days,
aft_mts_sat = tot_count_of_saturday_minutes,
aft_mts_sun = tot_count_of_sunday_minutes,
aft_mts = aft_mts_ost + aft_mts_oud + aft_mts_sat + aft_mts_sun,
aft_hrs = aft_mts / 60,
aft_hrs_sys_rat = aft_mts / sys_mts_tot,
# appointment (apt) metrics
apt_tot = tot_count_of_appointments,
apt_pmo = apt_tot / n_months, # pmo = per month
apt_min = min_count_of_appointments,
apt_max = max_count_of_appointments,
# minutes per appointment (mpa)
mpa_ib = tot_minutes_in_in_basket_per_appointment,
mpa_cr = tot_minutes_in_clinical_review_per_appointment,
mpa_nl = tot_minutes_in_notes_letters_per_appointment,
mpa_or = tot_minutes_in_orders_per_appointment,
mpa = mpa_ib + mpa_cr + mpa_nl + mpa_or,
mpa_pct_ib = ifelse(mpa_ib > 0, mpa_ib / mpa, NA),
mpa_pct_cr = ifelse(mpa_cr > 0, mpa_cr / mpa, NA),
mpa_pct_nl = ifelse(mpa_nl > 0, mpa_nl / mpa, NA),
mpa_pct_or = ifelse(mpa_or > 0, mpa_or / mpa, NA),
# --- Inbox metrics ---
# message (msg) metrics
msg_mar_tot = tot_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_tot = tot_count_of_patient_call_messages_received,
msg_res_tot = tot_count_of_result_messages_received,
msg_rxa_tot = tot_count_of_rx_auth_messages_received,
msg_all_tot = msg_mar_tot + msg_pcm_tot + msg_res_tot + msg_rxa_tot,
msg_mar_pmo = msg_mar_tot / n_months,
msg_pcm_pmo = msg_pcm_tot / n_months,
msg_res_pmo = msg_res_tot / n_months,
msg_rxa_pmo = msg_rxa_tot / n_months,
msg_all_pmo = msg_all_tot / n_months,
msg_mar_max = max_count_of_patient_medical_advice_requests_messages_received,
msg_pcm_max = max_count_of_patient_call_messages_received,
msg_res_max = max_count_of_result_messages_received,
msg_rxa_max = max_count_of_rx_auth_messages_received,
msg_mar_dtc = tot_average_days_until_patient_medical_advice_request_message_marked_done,
msg_pcm_dtc = tot_average_days_until_patient_call_messages_marked_done,
msg_res_dtc = tot_average_days_until_result_message_marked_done,
msg_rxa_dtc = tot_average_days_until_rx_auth_message_marked_done,
msg_all_dtc = (msg_mar_dtc + msg_pcm_dtc + msg_res_dtc + msg_rxa_dtc) / 4,
# in-basket (ib) metrics
ib_mts = tot_count_of_in_basket_minutes,
ib_mts_max = max_count_of_in_basket_minutes,
ib_hrs = ib_mts / 60,
ib_hrs_max = ib_mts_max / 60,
ib_hrs_pmo = ib_hrs / n_months,
ib_mts_per_apt = ib_mts / apt_tot,
ib_sys_rat = ib_mts / sys_mts_tot,
ib_sch_rat = ib_hrs / sch_hrs_tot
) |>
select(
id, type, group, n_months,
starts_with(c("msg_", "ib_", "sch_", "sys_", "aft_", "apt_", "mpa_"))
)
# Filter to providers with at least 0.1 FTE (schedule hours per month >= 16 hours)
final <- engineered |> filter(sch_hrs_pmo >= 16)
# Save all datasets
if (!dir.exists("data")) {
dir.create("data")
}
raw |> saveRDS("data/raw.rds")
clean |> saveRDS("data/clean.rds")
wide |> saveRDS("data/wide.rds")
long |> saveRDS("data/long.rds")
monthly |> saveRDS("data/monthly.rds")
aggregated |> saveRDS("data/aggregated.rds")
engineered |> saveRDS("data/engineered.rds")
final |> saveRDS("data/final.rds")
